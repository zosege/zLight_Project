/*** ARDUINO CODE FOR zLight ***/
#include "FastLED.h"

// Количество светодиодов в конкретной сборке
#define NUM_LEDS 185 // (34+59+34+58)

// Из документации на FastLED:
// For led chips like Neopixels, which have a data line, ground, and power, you just
// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,
// ground, and power), like the LPD8806 define both DATA_PIN and CLOCK_PIN
#define DATA_PIN 3   // линия для выдачи данных на ленту 
CRGB leds[NUM_LEDS]; // Массив для хранения цветов каждого светодиода на ленте (нужен для FastLED)

#define BUF_SIZE 30  // размер приемного буфера по USB (в байтах, кратно трем!)
char buf[BUF_SIZE];  // приемный буфер USB
byte Link = 0;       // признак наличия связи с ПК (1 - есть, 0 - нет)
unsigned long lastTime;                  // Время последнего обновления светодиодов на ленте
const unsigned long fadeTimeout = 500;   // Таймаут (в мс) на отсутствие связи с ПК, после которого тушим ленту

#define LED_PIN 13   // на всякий случай, можем моргать светодиодом на плате ардуино, подключенного к 13 выводу (сейчас не используется)

byte darker = 255;   // коэффициент затемнения каждого канала каждого пиксела в ленте (для плавного включения ленты)

void setup() { 
  FastLED.addLeds<WS2812, DATA_PIN, GRB>(leds, NUM_LEDS); // Инициализируем библиотеку FastLED, порядок каналов у ленты G-R-B

  //Test(); // Чтобы узнать какой-порядок каналов у вашей ленты, раскоментите строку ниже (см. void Test() ниже)
  
  blackoutAll(); // Полностью тушим все светодиоды на ленте

  Serial.begin(115200);   // Настраиваем обмен по USB
  Serial.setTimeout(100); // таймаут 100 мс

  lastTime = millis();    // Лента только-только обновлена
  
  pinMode(LED_PIN, OUTPUT); // Разрешим управлять светодиодом на LED_PIN (на всякий случай)
}

void loop() { 
  //Test(); // Для отладочных целей, лучше раскомментировать строку ниже, и закоментировать весь остаток функции до конца
  
  uint16_t len = NUM_LEDS*3; // Длина массива от ПК, которую ещё необходимо принять
  uint16_t cnt = 0;          // Количество принятых байт в текущем кусочке массива
  uint16_t led = 0;          // Количество светодиодов, для которых уже известны необходимые цвета
  uint16_t errors = 0;       // Счетчик ошибок (таймаутов) обмена с ПК


  //Serial.flush(); // Работает и без него

  Serial.write( 'z' ); // Посылаем сигнал "Мы готовы"
 
  
  while (len > 0)                                 // Пока есть что принимать с USBб будем делать:
  {
   if (len > BUF_SIZE)                            // Если оставшиеся байты для приема превосходят ёмкость приемного буфера, то...
    {
     cnt = Serial.readBytes(buf, BUF_SIZE);       //... считаем с USB только BUF_SIZE байт и запомним сколько реально было принято
     len -= cnt;                                  // уменьшим ожидаемое число байт, на количество реально принятых
    } 
   else                                           // ... иначе, осталось принять байт меньше, чем ёмкость буфера, то...
    {
     cnt = Serial.readBytes(buf, len);            // ... постараемся принять все оставшиеся на USB байты и запомним сколько реально было принято
     len -= cnt;                                  // уменьшим ожидаемое число байт, на количество реально принятых 
    } 

   if (cnt == 0)                                  // Если мы так и не приняли ниодного байта, то повидимому таймаут обмена (ПК не отвечает)...
     errors++;                                    // ... увеличим счетчик ошибок обмена
   
   if (errors > 2) break;                         // Если ошибок уже больше 2 (случайные сбои обмена по USB не будем считать фатальными), то прервев прием байт от ПК
   
   for (uint16_t i=0; i<cnt;i+=3)                 // Разберём принятые байты и разложим в массив цветов светодиодов (в этом месте, закопана потенциальная ошибка, если cnt не кратно 3, за время пуско-наладки ни разу не возникла, но тем не менее)
    {
      leds[led].r = buf[i + 0];                   // Красный канал
      leds[led].g = buf[i + 1];                   // Зеленый канал
      leds[led].b = buf[i + 2];                   // Синий канал
      
      if (leds[led].r >= darker) leds[led].r -= darker; else leds[led].r = 0; // Учтем коэффициент 
      if (leds[led].g >= darker) leds[led].g -= darker; else leds[led].g = 0; // затемнения каналов 
      if (leds[led].b >= darker) leds[led].b -= darker; else leds[led].b = 0; // (для плавного включения ленты)
      
      led++;                                     // Очередной светодиод имеет новые цвета
    }
  }
  
  if (led == NUM_LEDS)                           // Если мы для всех светодиодов знаем цвета на текущем цикле, то...
   {
     lastTime = millis();                        // ... лента обновилась прямо сейчас
     FastLED.show();                             // ... отобразим новое состояние ленты
     Link = 1;                                   // ... у нас есть связь с ПК
     if (darker >= 7) darker -= 7; else darker = 0; // ... начнем плавно уменьшать коэффициент затемнения каналов вплоть до нуля
   }
  
  if ( millis() - lastTime > fadeTimeout )       // Если у нас давно не было обновления ленты, то...
   {
    if (Link == 1)                               // ... если до этого связь с ПК была, то...
      BlurToDark();                              // ... плавно потушим ленту
    else                                         // ... иначе (связи с ПК не было), то...
      blackoutAll();                             // ... будем держать ленту выключенной (желающие тут могут засекать время, как долго мы без связи и реализовать какое-нибудь фоновое/аварийное свечение ленты без ПК)
    Link = 0;                                    // ... связи с ПК нет :(
   } 
}

////////////////////////////////////////////////////////////
// Отключить всю ленту (мгновенно)
void blackoutAll() 
{
   for ( int16_t i = 0; i < NUM_LEDS; i++ ) // Перебирая все светодиоды на ленте...
    {
     leds[i].r = 0;                         // тушим каждый канал
     leds[i].g = 0;
     leds[i].b = 0;
    }

  FastLED.show();                           // Выводим новые значения цвета (черный) на ленту
  darker=255;                               // Коэффициент затемнения устанавливаем на максимум
}

////////////////////////////////////////////////////////////
// Отключить всю ленту (плавно)
void BlurToDark() 
{
  for ( int16_t j = 0; j < 128; j++ )       // в 128 итераций...
  {
   for ( int16_t i = 0; i < NUM_LEDS; i++ ) // перебирая все светодиоды на ленте...
    {
     if (leds[i].r >= 2) leds[i].r -= 2;    // с шагом 2 плавно тушим ленту
     if (leds[i].g >= 2) leds[i].g -= 2;
     if (leds[i].b >= 2) leds[i].b -= 2;
    }
   FastLED.show();                          // после каждой итерации обновляем цвета светодиодов в ленте
  } 
  
 blackoutAll();                             // а в конце на всякий случай полностью тушим ленту
}

////////////////////////////////////////////////////////////
// Тестовый режим работы скетча
void Test() 
{
  for ( int16_t i = 0; i < NUM_LEDS; i++ ) // Перебирая все светодиоды в ленте
    leds[i] = CRGB::Red;                   // делаем их 100% красными
  FastLED.show();                          // выводим новое состояние цветов (красный) на ленту
  delay(500);                              // ждем 500 мс
  
  for ( int16_t i = 0; i < NUM_LEDS; i++ ) // Перебирая все светодиоды в ленте
    leds[i] = CRGB::Green;                 // делаем их 100% зелёными
  FastLED.show();                          // выводим новое состояние цветов (зелёный) на ленту
  delay(500);                              // ждем 500 мс

  for ( int16_t i = 0; i < NUM_LEDS; i++ ) // Перебирая все светодиоды в ленте
    leds[i] = CRGB::Blue;                  // делаем их 100% синими
  FastLED.show();                          // выводим новое состояние цветов (синий) на ленту
  delay(500);                              // ждем 500 мс

  for ( int16_t i = 0; i < NUM_LEDS; i++ ) // Перебирая все светодиоды в ленте
    leds[i] = CRGB::Black;                 // делаем их не включенными
  FastLED.show();                          // выводим новое состояние цветов ("черный") на ленту
  delay(1000);                             // ждем 1000 мс

/*
 Важное замечание: 
 Таким образом, каждые 500 мс на ленту выводятся цвета в следующем порядке: красный (R), зелёный (G), синий (B), затем 1 секунду лента потушена
 Если вы в скетче разрешили работу функции Test() и у вас порядок цветов иной, то в зависимости от того, какой цвет у вас зажигается первым можно догадаться о порядке следования цветов по шине данных ленты,
 так, например, если у вас получился порядок B, R, G, то у вашей ленты истинный порядок цветов такой: B, R, G (задайте BRG в функции FastLED.addLeds<> внутри setup())
*/
}


